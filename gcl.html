<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GCL — Scanner & Mini-Compiler</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Prism for syntax highlight -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

  <!-- D3 for AST visualization -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    pre.codebox {
      min-height: 160px;
      max-height: 360px;
      overflow: auto;
      border-radius: 8px;
      padding: 12px;
    }
    /* AST panel */
    #ast-svg { width:100%; height:400px; border-radius:8px; background: white; }
    /* token card scrollbar fix */
    .tokens-list { max-height: 400px; overflow:auto; }
  </style>
</head>
<body class="bg-gradient-to-br from-sky-50 to-blue-100 min-h-screen p-8">
  <div class="max-w-7xl mx-auto">
    <div class="bg-white rounded-2xl shadow-lg p-6">
      <div class="flex items-center justify-between gap-4">
        <div>
          <h1 class="text-2xl font-bold text-blue-700 mb-0">GCL Lexical Scanner & Mini Compiler</h1>
          <p class="text-sm text-gray-600 mt-1"></p>
        </div>
        <div class="text-right">
          <div class="text-xs text-gray-500">Single-file HTML — offline ready</div>
          <div class="text-xs text-gray-400">Try sample code, then Parse → Export PDF</div>
        </div>
      </div>

      <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
        <div>
          <label class="font-semibold">Input GCL Code</label>
          <textarea id="code" class="w-full p-3 border rounded-lg mt-2 h-60 font-mono" spellcheck="false">
// contoh:
// guarded commands GCL-like
if B -> x := 1 fi

// example guarded:
if x > 0 -> y := y + 1 | x <= 0 -> y := y - 1 fi

do x > 0 -> x := x - 1 | x == 0 -> y := 5 od
          </textarea>

          <div class="flex gap-2 mt-4 flex-wrap">
            <button id="btnScan" onclick="doScan()" class="px-4 py-2 bg-blue-600 text-white rounded shadow hover:bg-blue-700">Scan</button>
            <button id="btnParse" onclick="doParse()" class="px-4 py-2 bg-indigo-600 text-white rounded shadow hover:bg-indigo-700">Parse</button>
            <button id="btnPdf" onclick="doPdf()" class="px-4 py-2 bg-gray-700 text-white rounded shadow hover:bg-gray-800">Export PDF</button>
            <button onclick="highlightCode()" class="px-3 py-2 border rounded text-gray-700">Highlight</button>
            <button onclick="loadExample()" class="px-3 py-2 border rounded text-gray-700">Load Example</button>
          </div>

          <div class="mt-4">
            <label class="font-semibold">Highlighted Source</label>
            <pre class="codebox"><code id="highlight" class="language-javascript"></code></pre>
          </div>
        </div>

        <div>
          <label class="font-semibold">Tokens</label>
          <div id="tokensPanel" class="mt-2 grid grid-cols-1 gap-2 tokens-list"></div>

          <label class="font-semibold mt-4 block">Parser & AST</label>
          <div id="parseInfo" class="mt-2 text-sm text-gray-700"></div>
          <svg id="ast-svg" class="mt-2"></svg>
        </div>
      </div>

      <div class="mt-6 bg-slate-50 p-4 rounded">
        <h3 class="font-semibold mb-2">Notes</h3>
        <ul class="list-disc pl-5 text-sm text-gray-700">
          <li>Scanner reports tokens with line & column information.</li>
          <li>Parser returns error with token position for easier debugging.</li>
          <li>Exported PDF includes token list and AST JSON.</li>
        </ul>
      </div>
    </div>
  </div>

<script>
// -------------------------
// Lexer (JS port of Python regex-based lexer)
// -------------------------
const TOKEN_SPECS = [
  ["COMMENT", /\/\/[^\n]*/y],
  ["NEWLINE", /\n/y],
  ["WHITESPACE", /[ \t\r]+/y],
  ["ARROW", /->/y],
  ["ASSIGN", /:=/y],
  ["OP", /==|<=|>=|!=|[+\-*/<>]/y],
  ["LPAREN", /\(/y],
  ["RPAREN", /\)/y],
  ["SEMI", /;/y],
  ["BAR", /\|/y],
  ["KEYWORD", /\b(if|then|else|fi|do|od)\b/y],
  ["NUMBER", /\b\d+\b/y],
  ["IDENT", /[A-Za-z_][A-Za-z0-9_]*/y],
  ["UNKNOWN", /./y],
];

// Build combined behavior: we'll iterate manualy using sticky regex (y flag)
function lex(code) {
  const tokens = [];
  let line = 1;
  let col = 1;
  let pos = 0;
  const length = code.length;

  while (pos < length) {
    let matched = false;
    for (let [type, regex] of TOKEN_SPECS) {
      regex.lastIndex = pos;
      const m = regex.exec(code);
      if (m && m.index === pos) {
        matched = true;
        const value = m[0];
        const start = pos;
        pos = regex.lastIndex;

        if (type === "NEWLINE") {
          line += 1;
          col = 1;
          break; // continue outer while
        }
        if (type === "WHITESPACE" || type === "COMMENT") {
          col += value.length;
          break;
        }
        if (type === "UNKNOWN") {
          tokens.push({type: "ERROR", value, line, col, index: start});
          col += value.length;
          break;
        }
        tokens.push({type, value, line, col, index: start});
        col += value.length;
        break;
      }
    }
    if (!matched) {
      // shouldn't happen due to UNKNOWN, but safe fallback
      tokens.push({type: "ERROR", value: code[pos], line, col, index: pos});
      pos += 1;
      col +=1;
    }
  }
  return tokens;
}

// -------------------------
// Parser (JS port of recursive descent Parser in Python)
// -------------------------
class ParseError extends Error {
  constructor(msg, token = null) {
    super(msg);
    this.token = token;
  }
}

class Parser {
  constructor(tokens) {
    this.tokens = [...tokens];
    this.pos = 0;
    // append EOF sentinel
    this.tokens.push({type: "EOF", value: "", line: -1, col: -1});
  }

  peek() {
    return this.tokens[this.pos] || {type: "EOF", value: "", line:-1, col:-1};
  }

  consume(expected_type=null, expected_value=null) {
    const tok = this.peek();
    if (expected_type && tok.type !== expected_type) {
      throw new ParseError(`Expected token type ${expected_type} but found ${tok.type} ('${tok.value}')`, tok);
    }
    if (expected_value && tok.value !== expected_value) {
      throw new ParseError(`Expected token value ${expected_value} but found ${tok.value}`, tok);
    }
    this.pos += 1;
    return tok;
  }

  parse_program() {
    const body = this.parse_stmt_list();
    return {node: "Program", body};
  }

  parse_stmt_list() {
    const stmts = [];
    while (true) {
      const tok = this.peek();
      if (tok.type === "EOF") break;
      if (tok.type === "KEYWORD" && (tok.value === "fi" || tok.value === "od")) break;
      if (!(tok.type === "KEYWORD" || tok.type === "IDENT")) break;
      const stmt = this.parse_stmt();
      stmts.push(stmt);
      if (this.peek().type === "SEMI") {
        this.consume("SEMI");
      }
    }
    return stmts;
  }

  parse_stmt() {
    const tok = this.peek();
    if (tok.type === "KEYWORD" && tok.value === "if") return this.parse_if();
    if (tok.type === "KEYWORD" && tok.value === "do") return this.parse_do();
    if (tok.type === "IDENT") return this.parse_assignment();
    throw new ParseError(`Unexpected token in statement: ${tok.type} '${tok.value}'`, tok);
  }

  parse_if() {
    this.consume("KEYWORD", "if");
    const guards = this.parse_guard_list();
    if (this.peek().type === "KEYWORD" && this.peek().value === "fi") {
      this.consume("KEYWORD","fi");
      return {node: "If", guards};
    }
    throw new ParseError("Expected 'fi' to close 'if'", this.peek());
  }

  parse_do() {
    this.consume("KEYWORD","do");
    const guards = this.parse_guard_list();
    if (this.peek().type === "KEYWORD" && this.peek().value === "od") {
      this.consume("KEYWORD","od");
      return {node: "Do", guards};
    }
    throw new ParseError("Expected 'od' to close 'do'", this.peek());
  }

  parse_guard_list() {
    const guards = [this.parse_guard()];
    while (this.peek().type === "BAR") {
      this.consume("BAR");
      guards.push(this.parse_guard());
    }
    return guards;
  }

  parse_guard() {
    const cond = this.parse_expr();
    if (this.peek().type === "ARROW") {
      this.consume("ARROW");
    } else {
      throw new ParseError("Expected '->' in guard", this.peek());
    }
    const body = this.parse_stmt_list();
    return {node: "Guard", cond, body};
  }

  parse_assignment() {
    const ident = this.consume("IDENT");
    if (this.peek().type === "ASSIGN") {
      this.consume("ASSIGN");
    } else {
      throw new ParseError("Expected ':=' in assignment", this.peek());
    }
    const expr = this.parse_expr();
    return {node: "Assign", target: ident.value, expr};
  }

  // Expression parsing (precedence climbing via methods)
  parse_expr() { return this.parse_equality(); }

  parse_equality() {
    let left = this.parse_relational();
    while (this.peek().type === "OP" && (this.peek().value === "==" || this.peek().value === "!=")) {
      const op = this.consume("OP").value;
      const right = this.parse_relational();
      left = {node: "BinaryOp", op, left, right};
    }
    return left;
  }

  parse_relational() {
    let left = this.parse_additive();
    while (this.peek().type === "OP" && ["<", ">", "<=", ">="].includes(this.peek().value)) {
      const op = this.consume("OP").value;
      const right = this.parse_additive();
      left = {node: "BinaryOp", op, left, right};
    }
    return left;
  }

  parse_additive() {
    let left = this.parse_term();
    while (this.peek().type === "OP" && (this.peek().value === "+" || this.peek().value === "-")) {
      const op = this.consume("OP").value;
      const right = this.parse_term();
      left = {node: "BinaryOp", op, left, right};
    }
    return left;
  }

  parse_term() {
    let left = this.parse_factor();
    while (this.peek().type === "OP" && (this.peek().value === "*" || this.peek().value === "/")) {
      const op = this.consume("OP").value;
      const right = this.parse_factor();
      left = {node: "BinaryOp", op, left, right};
    }
    return left;
  }

  parse_factor() {
    const tok = this.peek();
    if (tok.type === "NUMBER") {
      this.consume("NUMBER");
      return {node: "Number", value: parseInt(tok.value,10)};
    }
    if (tok.type === "IDENT") {
      this.consume("IDENT");
      return {node: "Ident", name: tok.value};
    }
    if (tok.type === "LPAREN") {
      this.consume("LPAREN");
      const e = this.parse_expr();
      if (this.peek().type !== "RPAREN") {
        throw new ParseError("Missing closing ')'", this.peek());
      }
      this.consume("RPAREN");
      return e;
    }
    throw new ParseError("Unexpected token in factor", tok);
  }
}

// Helper to run parser
function parse_tokens(tokens) {
  const lex_errors = tokens.filter(t => t.type === "ERROR");
  if (lex_errors.length > 0) {
    throw new ParseError("Lexical errors present", lex_errors[0]);
  }
  const parser = new Parser(tokens);
  return parser.parse_program();
}

// -------------------------
// Utilities: convert AST for D3 tree and pretty JSON
// -------------------------
function convertAstToTree(ast) {
  function nodeify(obj) {
    if (obj === null || typeof obj === "undefined") return {name: "null"};
    if (typeof obj === "string" || typeof obj === "number") return {name: String(obj)};
    if (obj.node === undefined) {
      // Plain object (like Program with body)
      const name = obj.type || "Object";
      const children = [];
      for (const k of Object.keys(obj)) {
        children.push({name: `${k}`, children: [nodeify(obj[k])]});
      }
      return {name, children};
    }
    const name = obj.node || (obj.type || "Node");
    const children = [];
    for (const k of Object.keys(obj)) {
      if (k === "node") continue;
      const v = obj[k];
      if (Array.isArray(v)) {
        children.push({name: k, children: v.map(nodeify)});
      } else if (typeof v === "object") {
        children.push({name: k, children: [nodeify(v)]});
      } else {
        children.push({name: `${k}: ${v}`});
      }
    }
    return {name, children};
  }
  return nodeify(ast);
}

// -------------------------
// D3 drawing function
// -------------------------
function drawTree(root) {
  const svg = d3.select("#ast-svg");
  svg.selectAll("*").remove();
  const width = svg.node().clientWidth || 900;
  const height = svg.node().clientHeight || 400;

  const g = svg.append("g").attr("transform","translate(20,20)");
  const treeLayout = d3.tree().size([height-40, width-120]);
  const hierarchyData = d3.hierarchy(root, d => d.children || []);
  const tree = treeLayout(hierarchyData);

  // links
  g.selectAll('path.link')
    .data(tree.links())
    .enter()
    .append('path')
    .attr('class','link')
    .attr('d', d3.linkHorizontal()
                 .x(d => d.y)
                 .y(d => d.x))
    .attr('fill','none')
    .attr('stroke','#888')
    .attr('stroke-width',1.2);

  // nodes
  const node = g.selectAll('g.node')
    .data(tree.descendants())
    .enter()
    .append('g')
    .attr('transform', d => `translate(${d.y},${d.x})`);

  node.append('circle').attr('r',6).attr('fill','#2563eb');
  node.append('text')
    .attr('dx', 10)
    .attr('dy', 4)
    .text(d => d.data.name)
    .style('font-size','12px');
}

// -------------------------
// UI -> Integration functions (scan / parse / pdf)
// -------------------------
function renderTokens(tokens) {
  const panel = document.getElementById('tokensPanel');
  panel.innerHTML = '';
  if (!tokens || tokens.length === 0) {
    panel.innerHTML = `<div class="p-3 bg-green-50 rounded">No tokens</div>`;
    return;
  }
  tokens.forEach(t => {
    const colorClass = t.type === 'ERROR' ? 'bg-red-100 border-red-300' : 'bg-white border';
    const html = `<div class="p-3 ${colorClass} rounded shadow-sm border-gray-200">
      <div class="flex justify-between items-start">
        <div>
          <div class="font-semibold">${escapeHtml(t.value)}</div>
          <div class="text-xs text-gray-500">${t.type} • line ${t.line}, col ${t.col}</div>
        </div>
        <div class="text-xs text-gray-600">${t.index}</div>
      </div>
    </div>`;
    panel.insertAdjacentHTML('beforeend', html);
  });
}

function escapeHtml(str) {
  if (!str && str !== 0) return '';
  return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
}

async function doScan() {
  const code = document.getElementById('code').value;
  document.getElementById('tokensPanel').innerHTML = `<div class="p-3 bg-yellow-50 rounded">Scanning...</div>`;
  try {
    const tokens = lex(code);
    renderTokens(tokens);
    document.getElementById('highlight').textContent = code;
    Prism.highlightElement(document.getElementById('highlight'));
  } catch (e) {
    document.getElementById('tokensPanel').innerHTML = `<div class="p-3 bg-red-50 rounded">Scanner error: ${escapeHtml(e.message)}</div>`;
  }
}

async function doParse() {
  const code = document.getElementById('code').value;
  document.getElementById('parseInfo').innerText = 'Parsing...';
  try {
    const tokens = lex(code);
    // show tokens first
    renderTokens(tokens);
    const ast = parse_tokens(tokens);
    document.getElementById('parseInfo').innerHTML = `<div class="p-3 bg-green-50 rounded">Parse OK — AST generated</div>`;
    const root = convertAstToTree(ast);
    drawTree(root);
    // keep highlighted code
    document.getElementById('highlight').textContent = code;
    Prism.highlightElement(document.getElementById('highlight'));
  } catch (err) {
    if (err instanceof ParseError) {
      const tok = err.token;
      let msg = escapeHtml(err.message);
      document.getElementById('parseInfo').innerHTML = `<div class="p-3 bg-red-50 rounded">Parse Error: ${msg}</div>`;
      if (tok) {
        document.getElementById('parseInfo').innerHTML += `<div class="text-xs text-gray-600 mt-2">At token: ${escapeHtml(JSON.stringify(tok))}</div>`;
      }
      // show tokens if available
      try {
        const tokens = lex(code);
        renderTokens(tokens);
      } catch(e2){ /* ignore */ }
    } else {
      document.getElementById('parseInfo').innerHTML = `<div class="p-3 bg-red-50 rounded">Error: ${escapeHtml(err.message || String(err))}</div>`;
    }
  }
}

// -------------------------
// PDF export using jsPDF
// -------------------------
async function doPdf() {
  const code = document.getElementById('code').value;
  let tokens = [];
  let ast = null;
  try {
    tokens = lex(code);
    ast = parse_tokens(tokens);
  } catch (e) {
    // if parse fails, include tokens and error message
    tokens = lex(code);
    ast = {error: "Parse failed - see tokens / lexical errors", message: e.message};
  }

  // Build PDF
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({unit:'pt', format:'a4'});
  const margin = 40;
  const pageHeight = doc.internal.pageSize.getHeight();
  let y = margin;

  doc.setFont("helvetica", "bold");
  doc.setFontSize(16);
  doc.text("GCL Lexical & AST Report", margin, y);
  y += 20;
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  doc.text(`Generated: ${new Date().toISOString()}`, margin, y);
  y += 18;

  doc.setFont("helvetica", "bold");
  doc.setFontSize(12);
  doc.text("Tokens:", margin, y);
  y += 14;
  doc.setFont("helvetica", "normal");
  doc.setFontSize(9);

  // tokens table-like
  for (const t of tokens) {
    const line = `${t.line}:${t.col}  ${t.type.padEnd(7,' ')}  ${t.value}`;
    doc.text(line, margin, y);
    y += 12;
    if (y > pageHeight - margin - 60) {
      doc.addPage();
      y = margin;
    }
  }

  doc.addPage();
  y = margin;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(12);
  doc.text("AST (JSON):", margin, y);
  y += 16;
  doc.setFont("courier", "normal");
  doc.setFontSize(8);

  const astText = JSON.stringify(ast, null, 2);
  const lines = astText.split(/\r?\n/);
  for (let line of lines) {
    // split long lines
    const chunks = splitLine(line, 90);
    for (const ch of chunks) {
      doc.text(ch, margin, y);
      y += 10;
      if (y > pageHeight - margin - 20) {
        doc.addPage();
        y = margin;
      }
    }
  }

  doc.save("gcl_report.pdf");
}

function splitLine(str, maxLen) {
  const res = [];
  for (let i=0;i<str.length;i+=maxLen) res.push(str.slice(i,i+maxLen));
  return res;
}

// -------------------------
// Helpers: example loader, highlight init
// -------------------------
function highlightCode(){
  const code = document.getElementById('code').value;
  document.getElementById('highlight').textContent = code;
  Prism.highlightElement(document.getElementById('highlight'));
}

function loadExample(){
  const sample = `// contoh:
// guarded commands GCL-like
if B -> x := 1 fi

// example guarded:
if x > 0 -> y := y + 1 | x <= 0 -> y := y - 1 fi

do x > 0 -> x := x - 1 | x == 0 -> y := 5 od
`;
  document.getElementById('code').value = sample;
  highlightCode();
}

// initialize highlight
document.getElementById('highlight').textContent = document.getElementById('code').value;
Prism.highlightElement(document.getElementById('highlight'));



</script>
<!-- ======================= -->
<!-- Tahap 2: Enhancements -->
<!-- ======================= -->
<script>


function updateStats(tokens) {
  const total = tokens.length;
  const errors = tokens.filter(t => t.type === 'ERROR').length;
  const el = document.getElementById('statsBadge');
  if (el) el.textContent = `Tokens: ${total} • Errors: ${errors}`;
}

// Token click -> highlight code position
function attachTokenClickHandlers() {
  const panel = document.getElementById('tokensPanel');
  // delegate click
  panel.addEventListener('click', (ev) => {
    const card = ev.target.closest('[data-token-index]');
    if (!card) return;
    const idx = parseInt(card.getAttribute('data-token-index'), 10);
    const tokens = window.__lastTokens || [];
    const tok = tokens[idx];
    if (!tok) return;
    // highlight in code textarea by computing char index via scanning lines
    highlightTokenInCode(tok);
    // also mark the token card visually
    panel.querySelectorAll('.token-selected').forEach(n=>n.classList.remove('token-selected'));
    card.classList.add('token-selected');
  });
}

// Render tokens (override to attach data-token-index)
function renderTokens(tokens) {
  window.__lastTokens = tokens;
  const panel = document.getElementById('tokensPanel');
  panel.innerHTML = '';
  if (!tokens || tokens.length === 0) {
    panel.innerHTML = `<div class="p-3 bg-green-50 rounded">No tokens</div>`;
    return;
  }
  tokens.forEach((t, i) => {
    const colorClass = t.type === 'ERROR' ? 'bg-red-100 border-red-300' : 'bg-white border';
    const html = `<div data-token-index="${i}" class="p-3 ${colorClass} rounded shadow-sm border-gray-200 token-card" style="cursor:pointer">
      <div class="flex justify-between items-start">
        <div>
          <div class="font-semibold">${escapeHtml(t.value)}</div>
          <div class="text-xs text-gray-500">${t.type} • line ${t.line}, col ${t.col}</div>
        </div>
        <div class="text-xs text-gray-600">${t.index}</div>
      </div>
    </div>`;
    panel.insertAdjacentHTML('beforeend', html);
  });
  // update stats
  updateStats(tokens);
}

// Compute character offset from line+col (1-based col)
function charOffsetFromLineCol(text, line, col) {
  // lines split preserves newline characters by manual loop
  if (line <= 1) return Math.max(0, col - 1);
  let offset = 0;
  let curLine = 1;
  for (let i = 0; i < text.length && curLine < line; i++) {
    offset++;
    if (text[i] === '\n') curLine++;
  }
  return offset + Math.max(0, col - 1);
}

// Highlight token in textarea by selecting text range
function highlightTokenInCode(tok) {
  const area = document.getElementById('code');
  const txt = area.value;
  const start = charOffsetFromLineCol(txt, tok.line, tok.col);
  // token length
  const len = String(tok.value).length;
  area.focus();
  area.setSelectionRange(start, start + len);
  // flash background to show
  area.classList.add('ring-4', 'ring-yellow-300');
  setTimeout(()=> area.classList.remove('ring-4', 'ring-yellow-300'), 900);
}

// Search/filter tokens panel by substring (value or type)
function filterTokens(q) {
  const panel = document.getElementById('tokensPanel');
  if (!panel) return;
  const ql = q.trim().toLowerCase();
  panel.querySelectorAll('[data-token-index]').forEach(el => {
    const idx = parseInt(el.getAttribute('data-token-index'),10);
    const tokens = window.__lastTokens || [];
    const t = tokens[idx];
    const match = !ql || (String(t.value).toLowerCase().includes(ql) || String(t.type).toLowerCase().includes(ql));
    el.style.display = match ? '' : 'none';
  });
}

// Download AST JSON
function downloadAstJson() {
  try {
    const ast = window.__lastAst || {};
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(ast, null, 2));
    const a = document.createElement('a');
    a.setAttribute('href', dataStr);
    a.setAttribute('download', 'gcl_ast.json');
    document.body.appendChild(a);
    a.click();
    a.remove();
  } catch (e) {
    alert('Failed to download AST: ' + e.message);
  }
}

// Copy AST to clipboard
async function copyAstToClipboard() {
  try {
    const ast = window.__lastAst || {};
    await navigator.clipboard.writeText(JSON.stringify(ast, null, 2));
    showToast('AST copied to clipboard');
  } catch (e) {
    showToast('Copy failed: ' + e.message);
  }
}

// Small toast notification
function showToast(msg, timeout=1800) {
  const id = 'gcl-toast';
  let t = document.getElementById(id);
  if (t) t.remove();
  t = document.createElement('div');
  t.id = id;
  t.className = 'fixed left-1/2 -translate-x-1/2 bottom-24 bg-black/80 text-white px-4 py-2 rounded';
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(()=> t.remove(), timeout);
}

// Theme toggle (Tailwind dark class)
function toggleTheme() {
  document.documentElement.classList.toggle('dark');
  showToast('Theme toggled');
}

// Keyboard shortcuts
function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Ctrl+Enter -> parse
    if (e.ctrlKey && e.key === 'Enter') {
      e.preventDefault();
      doParse();
    }
    // Ctrl+S -> export PDF (prevent default save)
    if (e.ctrlKey && (e.key === 's' || e.key === 'S')) {
      e.preventDefault();
      doPdf();
    }
    // Ctrl+L -> focus code
    if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) {
      e.preventDefault();
      document.getElementById('code').focus();
    }
  });
}

// Highlight parse errors: if last parse threw ParseError with token info, visually mark token card
function markErrorToken(err) {
  try {
    if (!err || !err.token) return;
    const tok = err.token;
    const tokens = window.__lastTokens || [];
    // find token by index (we store index field)
    const idx = tokens.findIndex(t => t.index === tok.index && t.line === tok.line && t.col === tok.col);
    if (idx >= 0) {
      const panel = document.getElementById('tokensPanel');
      const el = panel.querySelector(`[data-token-index="${idx}"]`);
      if (el) {
        el.classList.add('border-red-500');
        el.scrollIntoView({behavior:'smooth', block:'center'});
      }
    }
  } catch(e) { /* ignore */ }
}

// AST zoom & pan using simple transform logic
function enableAstZoomPan() {
  const svg = d3.select("#ast-svg");
  const g = svg.select("g");
  if (g.empty()) return;
  // Use d3.zoom
  svg.call(d3.zoom().scaleExtent([0.5, 3]).on("zoom", (event) => {
    g.attr("transform", event.transform);
  }));
}

// Wrap doParse to set window.__lastAst and mark errors
const originalDoParse = window.doParse;
window.doParse = async function() {
  document.getElementById('parseInfo').innerText = 'Parsing...';
  try {
    const code = document.getElementById('code').value;
    const tokens = lex(code);
    renderTokens(tokens);
    const ast = parse_tokens(tokens);
    window.__lastAst = ast;
    document.getElementById('parseInfo').innerHTML = `<div class="p-3 bg-green-50 rounded">Parse OK — AST generated</div>`;
    const root = convertAstToTree(ast);
    drawTree(root);
    enableAstZoomPan();
    // keep highlighted code
    document.getElementById('highlight').textContent = code;
    Prism.highlightElement(document.getElementById('highlight'));
  } catch (err) {
    window.__lastAst = {error: err.message};
    if (err instanceof ParseError) {
      const tok = err.token;
      let msg = escapeHtml(err.message);
      document.getElementById('parseInfo').innerHTML = `<div class="p-3 bg-red-50 rounded">Parse Error: ${msg}</div>`;
      if (tok) {
        document.getElementById('parseInfo').innerHTML += `<div class="text-xs text-gray-600 mt-2">At token: ${escapeHtml(JSON.stringify(tok))}</div>`;
      }
      // still show tokens if possible
      try {
        const tokens = lex(document.getElementById('code').value);
        renderTokens(tokens);
        markErrorToken(err);
      } catch(e2){}
    } else {
      document.getElementById('parseInfo').innerHTML = `<div class="p-3 bg-red-50 rounded">Error: ${escapeHtml(err.message || String(err))}</div>`;
    }
  }
};

// Wrap doScan to set last tokens and attach click handlers
const originalDoScan = window.doScan;
window.doScan = async function() {
  const code = document.getElementById('code').value;
  document.getElementById('tokensPanel').innerHTML = `<div class="p-3 bg-yellow-50 rounded">Scanning...</div>`;
  try {
    const tokens = lex(code);
    window.__lastTokens = tokens;
    renderTokens(tokens);
    attachTokenClickHandlers(); // ensure delegated handler exists
    document.getElementById('highlight').textContent = code;
    Prism.highlightElement(document.getElementById('highlight'));
  } catch (e) {
    document.getElementById('tokensPanel').innerHTML = `<div class="p-3 bg-red-50 rounded">Scanner error: ${escapeHtml(e.message)}</div>`;
  }
};

// Initialize everything
function initEnhancements() {
  createFloatingToolbar();
  attachTokenClickHandlers();
  setupKeyboardShortcuts();
  // initial stats
  updateStats(window.__lastTokens || []);
  // observe AST svg resize to re-enable zoom pan
  const svg = document.getElementById('ast-svg');
  new ResizeObserver(() => enableAstZoomPan()).observe(svg);
}

// small style tweaks for selected token (injected)
(function injectStyles(){
  const css = `
    .token-selected { box-shadow: 0 8px 20px rgba(37,99,235,0.12); transform: translateY(-2px); }
    #gcl-toolbar button { background: transparent; }
    #gcl-toolbar input { background: white; }
    .dark #gcl-toolbar { background: rgba(31,41,55,0.9); color: #e5e7eb; }
  `;
  const s = document.createElement('style');
  s.appendChild(document.createTextNode(css));
  document.head.appendChild(s);
})();

// Kick off enhancements after short delay (ensures previous scripts loaded)
setTimeout(initEnhancements, 120);

// Expose some functions to console for debugging
window.gcl = {
  lex, parse_tokens, downloadAstJson, copyAstToClipboard, highlightTokenInCode, showToast
};

</script>

</body>
</html>